---
title: "소수 찾기"
excerpt: "Sieve of Eratosthenes"
use_math: true
categories:
 - algorithm
last_modified_at: 2020-11-27T20:15:00
---

# 소수 판별 (최적화)

주어진 자연수 N 이 소수인지 확인한다.

> 소수 (Prime Number) ? 1과 자기 자신으로만 나누어 떨어지는 (= 1과 자기 자신만을 약수로 갖는) 1보다 큰 자연수

간단하게는 2 부터 N-1 까지 탐색하면서 N을 나누었을 때 나머지가 0인 수가 있다면 N은 소수가 아님을 확인할 수 있다. 하지만 다음 특성을 사용하면 N-1 까지 탐색하지 않고도 소수 판별이 가능하여 탐색 시간을 단축시킬 수 있다.

**어떤 수 N 의 약수 집합은 $\sqrt{N}$ 을 기준으로 쌍을 갖는다.**

> 예)  
> 36의 약수 집합 = {1, 2, 3, 4, 6, 9, 12, 18, 36} : $\sqrt{36}=6$ 을 기준으로 쌍을 이룬다.  
> 28의 약수 집합 = {1, 2, 4, 7, 14, 28} : $\sqrt{28}\approx5$ 을 기준으로 쌍을 이룬다.

따라서 2 부터 $\sqrt{N}$ 까지 확인했을 때 N 에 대한 약수가 존재하지 않는다면 $\sqrt{N}$ 을 초과한 범위에서도 약수가 존재하지 않음을 알 수 있다.

```java
boolean isPrime(int n) {
  if(n <= 1) return false;

  for(int i = 2; i <= Math.sqrt(n); i++) {
    if(n%i == 0) return false;
  }

  return true;
}
```



# 소수 찾기 (Sieve of Eratosthenes)

주어진 자연수 N 까지 모든 소수를 찾는다.

1. 2 부터 N 까지 소수로 초기화 한다. (소수는 1보다 큰 자연수)
2. 2 부터 N 까지 탐색하며 **현재 숫자가 소수라면 범위 내에서 해당 소수의 모든 배수(2배수 이상)에 소수가 아님을 표시**한다.

어떤 자연수의 2배수 이상의 배수는 소수가 아님을 이용한 방법이다.

```java
void findPrime() {		
  for(int i = 2; i <= N; i++) {
    if(!primes[i]) continue;

    // 소수의 모든 (2배수 이상의) 배수는 소수가 아니다.
    for(int j = i*2; j <= N; j+=i) {
      primes[j] = false;
    }
  }
}

int N = 120;
boolean[] primes = new boolean[N+1]; // 1~N
for(int i = 2; i <= N; i++) primes[i] = true; // 초기화
findPrime();
```

다음과 같은 사실로 탐색 범위를 줄여 최적화 할 수 있다.

> 예)  
> 2의 배수: **4(=2\*2)**, 6(=2\*3), 8(=2\*4), 10(=2\*5), 12(=2\*6), 14(=2\*7)  
> 3의 배수: ~~6(=3\***2**)~~, **9(=3\*3)**, ~~12(=3\***4**)~~, 15(=3\*5), ~~18(=3\***6**)~~, 21(=3\*7)  
> ~~4의 배수~~: 2의 배수에 해당 (4의 배수는 모두 2의 배수)  
> 5의 배수: ~~10(=5\***2**)~~, ~~15(=5\***3**)~~, ~~20(=5\***4**)~~, **25(=5\*5)**, ~~30(=5\***6**)~~, 35(=5\*7)  
> ~~6의 배수~~: 2의 배수에 해당 (6의 배수는 모두 2의 배수)  
> 7의 배수: ~~14(=7\***2**)~~, ~~21(=7\***3**)~~, ~~28(=7\***4**)~~, ~~35(=7\***5**)~~, ~~42(=7\***6**~~), **49(=7\*7)**

소수의 모든 배수를 탐색할 때 `i*i` 이전의 배수들은 이미 제거된 상태임을 알 수 있다. 따라서 `i*i` 이후의 배수를 제거하면 된다.  또한 `i*i` 가 N 을 초과할 경우 배수 제거 과정을 진행하지 않기 때문에 $\sqrt{N}$ 을 초과한 값은 탐색할 필요가 없어진다.

```java
// 최적화 코드
void findPrime() {		
  for(int i = 2; i*i <= N /* 또는 i <= Math.sqrt(N) */; i++) {
    if(!primes[i]) continue;

    for(int j = i*i; j <= N; j+=i) {
      primes[j] = false;
    }
  }
}
```

