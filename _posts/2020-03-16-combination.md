---
title: "조합 (Combination)"
excerpt: ""
use_math: true
categories:
 - algorithm
last_modified_at: 2020-06-10T23:56:00
---

### 문제에서의 활용

- n개 중 m개 선택하기, 부분집합 구하기



### 구현

#### n개 중 2개를 선택하는 조합 (쌍을 만들기)

```java
for(int i = 0; i < arr.length-1; ++i){
    for(int j = i+1; j < arr.length; ++j){
        //arr[i], arr[j] 쌍 저장
    }
}
```
아래 재귀함수나 비트연산으로 구현할 수 있지만 쌍을 만드는 경우 이 구현이 더 간편하다.



#### 재귀함수

```java
final int N = //원소의 총 개수
final int M = //전체 원소 중 선택할 원소 개수
int[] arr = {//원소들 저장}
boolean[] visit = new boolean[N];

void combination(int index, int cnt){
  //이 개수에 대한 제한과 카운터 파라미터를 제거하면 모든 조합을 구할 수 있다.
  if(cnt == M){
    //현재 방문 상태인 원소 출력...
    return;
  }
  
  if(index >= N || cnt > M || visit[index]) return;
  	
  //부분집합을 구하는 경우 아래 1, 2번의 호출 순서에 따라 공집할을 먼저 구할지 모든 원소를 갖는 집합을 먼저 구할지 정할 수 있다.
  //1. 현재 인덱스를 선택하는 경우
  visit[index] = true;
  combination(index+1, cnt+1);
  visit[index] = false;
    
  //2. 현재 인덱스를 선택하지 않는 경우
  combination(index+1, cnt);
}
```



#### 비트연산

부분집합의 개수가 $2^n$(n: 원소의 개수) 이고 이는 시프트 연산`<<`이 $*2^n$임을 이용하여 구할 수 있다.

또한 이 범위 내의 수들을 비트로 표현하면 부분집합을 나타낸다.
예를들어 3개의 원소가 갖는 부분집합의 개수는 8개($2^3=8$) 이고 0 부터 7 까지의 수를 비트로 표현하면 000, 001, 010, 011, 100, 101, 110, 111 이 된다. 여기서 각 비트 위치를 원소들의 인덱스 위치로 보고, 해당 위치가 1인 경우 그 부분집합에 원소가 속한다 라고 생각할 수 있다.

위 비트 표현들 처럼 비트연산을 통한 조합 알고리즘 구현은 *주어진 원소 집합 배열의 순서를 보장하지 못한다.*

(n개의 원소 중 m개를 선택하려는 경우는 비트 표현들에서 1의 개수가 m과 같은지 확인하여 필터링하면 된다. 자바의 경우 `bitCount(..)`라는 함수를 제공한다.)

따라서 부분집합을 하나씩 확인하면서 각 부분집합에 속하는 원소의 인덱스를 찾아 출력해주면 된다.
부분집합에 해당 원소가 속하는지 확인하는 방법은 비트 연산자 `&`를 이용할 수 있다. 예를들어 101인 부분집합에 원소의 인덱스 1을 확인하면 1의 비트는 001이기 때문에 `&`연산 후 001이 출력된다. 이때 결과가 0이 아니면 부분집합에 속한다.

```java
final int N = //원소의 총 개수
final int M = //전체 원소 중 선택할 원소 개수
int[] arr = {//원소들 저장}
    
void combination(){
    int cnt = (1<<N); //원소의 총 개수로 만들 수 있는 모든 부분집합의 수
    
    //부분집합을 하나씩 확인한다.
    for(int i = 0; i < cnt; ++i){
        //해당 부분집합을 표현하는 비트의 1의 개수가 부분집합으로 선택할 원소의 개수와 같지 않은 경우는 제외
        //이 부분을 주석 처리하면 모든 부분집합을 구할 수 있다.
        if(Integer.bitCount(i) != M) continue;
        
        //각 원소의 인덱스가 해당 부분집합에 속해있는지 확인한다.
        for(int j = 0; j < N; ++j){
            if((i & (1<<j)) != 0){
                //원소 출력..
            }
        }
    }
}
```



### 문제

- A(3개), B(2개), C(5개) 인 경우 A, B, C 중 하나 이상을 선택하여 조합을 만드는 경우의 수는?  
  이 문제는 집합 A, B, C 각각이 갖는 부분집합들의 곱의 개수에서 공집합을 제외(하나 이상이기 때문에)한 나머지 개수와 같다.  
  따라서 $(2^3 * 2^2 * 2^5) - 1$ 가지의 경우의 수가 발생한다.

