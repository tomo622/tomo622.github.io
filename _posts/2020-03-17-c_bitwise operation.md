---
title: "비트 연산"
excerpt: "비트 연산자의 종류와 주의점을 정리하고, 값이 1인 비트의 개수를 구하는 함수를 구현한다."
categories:
 - c language
last_modified_at: 2020-03-17T16:26:00
---

### 비트 연산자 (Bitwise Operator)

| 연산자 | 의미        | 설명 |
| ------ | ----------- | ---- |
| &      | AND         | 모두 1일 때 1 |
| \|     | OR          | 하나만 1이여도 1 |
| ^      | XOR         | 두 비트가 다를 때 1 |
| ~      | NOT         | 비트 반전 |
| <<     | LEFT SHIFT  | 왼쪽을 비트 밀기 |
| \>>     | RIGHT SHIFT | 오른쪽으로 비트 밀기 |

### 시프트 연산자 (Shift Operator)

- 시프트 연산자의 의미
  `a << n` : $a * 2^n$ 
  `a >> n` : $a / 2^n$

- 부호가 있는 자료형에서의 사용
  (참고: 부호가 있는 자료형의 첫 번째 비트는 부호 비트로 1이면 음수, 0이면 양수를 나타낸다.)

  | 연산자 |                                                              |
  | ------ | ------------------------------------------------------------ |
  | <<     | 부호 비트(첫 번째 비트)에 위치하는 비트에 따라 부호가 결정된다. |
  | \>>    | 비트를 밀면서 빈 공간을 부호 비트(음수:1/양수:0)가 채운다.   |

  예) 113 << 2
  0111 0001 -> 1110 0010 -> 1100 0100
  1100 0100 = -60

  예) -125 >> 5
  1000 0011 -> 1100 0001 -> 1110 0000 -> 1111 0000-> 1111 1000 -> 1111 1100
  1111 1100 = -4
  
- 부호가 없는 자료형에서는 당연히 부호 비트가 없고 비트를 밀면서 빈 공간은 0으로 채운다.

### 참고

- 음수 표현 방법, 2의 보수 : 1의 보수에 더하기 1
  예) 0000 0001 (1) -> 1111 1110 + 1 -> 1111 1111 (-1)
  확인) 1 + (-1) = 0 -> 0000 0001 + 1111 1111 = [0001] 0000 0000 = 0



### 값이 1인 비트의 개수를 구하는 함수

```c
int  bitCount(int value) {
    int count = 0;
	int bitSize = sizeof(value) * 8;

	for (int i = 0; i < bitSize; i++) {
		int mask = 1 << i;
		if (value & mask) count++;
	}

	return count;
}
```

JAVA에서는 위와 동일한 기능의 함수 `bitCount(...)`를 제공한다.